https://www.cnblogs.com/cxuanBlog/p/15587465.html

;CPL是当前执行的程序或任务的特权级。它被存储在cs和ss的第0位和
;第1位上。在通常情况下，CPL等于代码所在的段的特权级。当程序转移
;到不同特权级的代码段时，处理器将改变CPL。

- 数据段DPL规定了可以访问此段的最低特权级。比如，一个数据
段的DPL是1，那么只有运行在CPL为0或者1的程序才有权访问
它。

》〉》〉》这段数据，只有操作系统才能访问？

- 非一致代码段（不使用调用门的情况下）：DPL规定访问此段的特权
级。比如，一个非一致代码段的特权级为0，那么只有CPL为0的程
序才可以访问它。

》〉》〉》〉CPL = DPL, RPL < DPL, 

调用门：DPL规定了当前执行的程序或任务可以访问此调用门的最
低特权级（这与数据段的规则是一致的）。

》〉》〉》〉

一致代码段和通过调用门访问的非一致代码段：DPL规定了访问此
段的最高特权级。比如，一个一致代码段的DPL是2，那么CPL为0
和1的程序将无法访问此段。

》〉》〉操作系统无法访问的段？

TSS：DPL规定了可以访问此TSS的最低特权级（这与数据段的规
则是一致的）。
g[

3.RPL (Requested Privilege Level)
RPL是通过段选择子的第0位和第1位表现出来的。处理器通过检查RPL
和CPL来确认一个访问请求是否合法。即便提出访问请求的段有足够的
特权级，如果RPL不够也是不行的。也就是说，如果RPL的数字比CPL
大（数字越大特权级越低），那么RPL将会起决定性作用，反之亦然。
操作系统过程往往用RPL来避免低特权级应用程序访问高特权级段内的
数据。当操作系统过程（被调用过程）从一个应用程序（调用过程）接收
到一个选择子时，将会把选择子的RPL设成调用者的特权级。于是，当操
作系统用这个选择子去访问相应的段时，处理器将会用调用过程的特权级
（已经被存到RPL中），而不是更高的操作系统过程的特权级（CPL）进行
特权检验。这样，RPL就保证了操作系统不会越俎代庖地代表一个程序去
访问一个段，除非这个程序本身是有权限的。

