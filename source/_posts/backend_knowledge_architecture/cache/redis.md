---
title: Redis缓存必知必会
date: 2022-02-16 23:20:03
updated:
mathjax: true
categories:
tags: 
- 缓存
---


1. 如何评价redis的高性能？为何要把Redis设计成单线程？

   (1)redis全内存，单线程，无锁。

   (2)redis Rehash 渐进式hash,双缓冲 + 分而治之思想 

    关于写入，仅写ht[1]，不再写入ht[0]；关于读取，优先读ht[1], 没有的话，再读取ht[0]

    渐进式迁移的过程中，一次迁移一个bucket。包括用于解决冲突的hash链。

2. Redis提供了哪些数据结构；每一种数据结构的使用场景、大致实现（编码方式、内存占用、时间复杂度）

##### 八种编码方式

    **INT** 64 位有符号整数类型的时候将会采用 INT 编码。 值在[0,1000)之间。 如果存入整数的值在[0,1000)中Redis将不会创建新的对象,而是直接指向**共享对象**,键值不额外占用空间。

    **EMBSTR**(EmbeddedString， 当存储的字符串长度较短时(len<=44 字节),Redis将会采用 embstr 编码，避免再次分配内存， 复用redis object)。这个长度是咋计算出来的呢？ 跟redis的底层内存池有关系。 64字节减去一些元数据。

    **RAW** 原始字符串

    **ZIPLIST** (压缩列表，连续内存，内存利用率高，增删改查效率低下；当hash、zset、list元素少且内容不大时使用该编码),

    **QUICK_LIST**（list元素较多时使用）

    **INTSET**(整数集合，当set元素较少时，使用该编码,从小到大的顺序存储，方便做交、并、差集运算。

    **HASH**（hash元素较多时使用） 渐进式扩容缩容策略

    **SKIPLIST**（跳表，zset元素多时使用）

##### 数据结构与编码关系

|  数据结构 | 紧凑实现 | 大致实现 |
|  ----  | ----  | ---- |
|  string | INT(仅限long类型的string), EMBSTR(字符串比较短) |RAW（普通字符串）|
|  hash | ZIPLIST（元素较少，成员较小）|HASH|
|  zset | ZIPLIST（元素较少，成员较小）|SKIPLIST|
|  set | INTSET（集合元素不多, 且元素可以表示为int）|HASH|
|  list | ZIPLIST（元素较少，成员较小）|QUICK_LIST|

![在这里插入图片描述](https://images.gitbook.cn/0bc2bef0-a343-11ea-a506-f32f5295a5a9)

#### Redis的可靠存储

redis是如何实现可靠存储的：真的可靠吗？ AOF、RDB有啥区别？ 分别适用于什么场景？

借助AOF、RDB可以一定程度上减少数据的损失，但是都无法做到数据的100%。

RDB，定期fork一个子进程，通过copy on write技术，来进行内存的dump，成本相对AOF较高，所以不可能很短时间内就dump一次，所以如果内存中的数据还没有来得及dump到RDB，那么会丢失比较多的数据，好处是借助RDB恢复数据比较快。

AOF，定期（通常是s级别）append 写操作命令到文件中，只是简单的写一次磁盘，所以性能较好，如果新的命令append到aof之间发生宕机，丢失的数据也比较少。缺点是每次基于AOF恢复数据会比较慢。

Redis 3.0 基于checkpoint思想的新持久化方式。

#### Redis的高可用性

redis tw代理模式与cluster集群模式分别是如何工作的？ 哪一种模式使用了一致性Hash?

两者都是为了解决单机数据存不下的问题。数据存不下，只能通过多台来存。

客户端通过tw代理模式访问redis集群，数据分片使用了一致性hash，以尽可能减少某台redis机器不可用造成的影响；

官方的cluster集群方案是由客户端sdk来维护slot分布，数据分片分片是通过CRC32(key)%16834来实现。无中心化，node之间通过gossip协议来进行通信，选主等。

另外值得一提的是Redis哨兵模式。这种模式只能解决高可用的问题，但是无法解决数据太大的问题。

另外，redis cluster还尝试解决高可用的问题，但是由于CAP理论，他选择了可用性，丢失了一致性。 丢失一致性的点在于：1）异步复制；2）网络分区。

![异步复制导致数据丢失](https://pic2.zhimg.com/80/v2-1530e8c407dd674e77ee7dc36295b161_1440w.jpg)

#### Redis 实现分布式锁

1. 如何通过Redis实现一个“可靠”的分布式锁？

分布式锁的特性：排他性、无死锁、高可用。

先说加锁，setnx命令，支持cas操作，并且支持设置超时时间。通过设置超时时间这个功能点，可以避免加锁后进程挂掉造成的锁没法释放的问题。但是这种加锁方案还有一个缺点，那就是超时时间很难设置的很合理，设置过短可能会引起加锁时间内不足以完成业务逻辑；设置过长又导致宕机恢复时间过长。这种情况下，我们可以额外启动一个WATCH-dog线程来监视这些锁，如果锁快要到期了，就调用expire命令对锁进行续期；业务完成时禁用watch-dog即可。

再说解锁，理想情况下，解锁时只要通过del命令来把锁定的key删除即可。但是实际情况可能会更复杂一些。第一个问题，如果删除的key不是加的锁怎么办？ 容易想到，加锁时，设置key的value为一个unique id。 解锁删除时，先get一下key，看看key对应的value是不是跟预期的id相符，如果相符，del；否则，noop，说明我正准备删除别人加的锁。但是刚才的方案，还有一个缺陷那就是get跟del两个操作不是一个原子的，中途可能会被打断。如果真的被打断，还是会出现误解锁的过程。此时我们可以借助lua脚本将刚才的两个步骤原子化。至此，解锁操作才算基本完成。

上面的方案还有啥问题呢？ 如果主从同步未完成，而主挂掉了，从上位之后，会导致之前加的锁失效。 这个问题，官方给的解决方案是使用redis cluster的红锁来解决。

最后再提一下，除了redis可以实现分布式锁，还可以通过mysql数据库（version乐观锁，for update悲观锁），zookeeper等来实现分布式锁。

#### redis 淘汰策略

- noeviction:返回错误当内存限制达到，并且客户端尝试执行会让更多内存被使用的命令。
- allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
- volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
- allkeys-random: 回收随机的键使得新添加的数据有空间存放。
- volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间 存放。
  