线性选择问题

选择问题定义，实际上所有处理均可以推广到集合中包含重复数值的情形。

输入：一个包含n个（不同的）数的集合A和一个数i，1<=i<=n。

输出：元素x属于A，它恰大于A中其他的i-1个元素。


1、最大值最小值

针对一个序列取得最大和最小值均需要n-1次比较。这是一个下限，确定最大值或者最小值的算法可以看作各个元素之间一场锦标赛，每次比较都是一场比赛，两个元素中较小的或者较大的获胜，除了最终的最大值和最小值，所有其他元素都需要输一次，所以n-1次是必须的。

接下来是一些比较有意思的问题，比如同时找出最小值和最大值，当然可以n-1次比较找出最大值，然后n-2次比较找出最小值，不过还是有比这个更好一点的算法，把元素两两分组，然后比较产生一个较大的值和较小的值，然后较大的值中产生最大值，较小的值中产生最小值，此时需要比较操作的次数至多3|_n/2_|。

还有一个比较问题是同时找出最大第二大或者最小次小元素的比较次数，简单的当然是2n-3，不过也有一个分组的方法能够达到n+lgn-2的比较次数。比较方法如下：

上面已经说明了，找出最值最少的比较次数n-1，所以上面寻找的方法也是n-1次，不信可以累计求和，不过这样求最值的过程中最值上来的时候有一条路径被记录，这条路径的长度为lgn，找出次大值或者次小值直接在这个路径上寻找就只需要lgn-1的比较次数。


Maximum and minimum of an array using minimum number of comparisons
Write a C function to return minimum and maximum in an array. You program should make minimum number of comparisons.

解答思路：

法1: Pair Compare
目标：尽可能的减少比较，如何确定a[i]是不是最小值或者最大值呢？

基于比较，消除不确定性
a[i]跟a[i+1] 比较之后？
a[i] 如果比 a[i+1] 则a[i]才有可能跟max比较；a[i+1] 才有可能跟min比较；

结论：3次比较消除了2个元素的的不确定性；

a[i]跟min, max比较；
a[i+1]跟min, max比较；
结论：4次比较，完成了2个元素的确定性；

法2: Divide and Conquer
如果有两个元素？ 怎么选择最大值最小值？
如果有一个元素，怎么选择最大值最小值？
左半部分已经有了最大值，最小值；右半部分已经有了最小值最大值： 如何确定merge之后的最小值最大值？


2、线性时间选择

数组：找第k大的数 （无序数组） O(N) -> 数组无法修改，额外空间O(1) 时间O(N)


