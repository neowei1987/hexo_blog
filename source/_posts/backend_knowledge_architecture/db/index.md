---
title: 数据库必知必会
date: 2022-02-16 23:20:03
mathjax: true
categories: 
tags: 
- 数据库
---

### 自增ID

1、一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 Mysql 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15 ？

(1) 如果表的类型是 MyISAM，那么是 18

因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里，重启 MySQL 自增主键的最大ID 也不会丢失

（2）如果表的类型是 InnoDB，那么是 15

InnoDB 表只是把自增主键的最大 ID 记录到内存中，所以重启数据库或者是对表进OPTIMIZE 操作，都会导致最大 ID 丢失

### 字符串索引

还有没有其他方式帮助字符串建立索引

比如能够给确定业务需求里面只有按照身份证等值查询的需求，需要给身份证加索引，有没有什么办法，占用更小空间，也能达到相同的查询效率。

第一种方式是使用倒序存储

【基础假设】存储的字符串**后半部分的区分度相对更高**

身份证最后 6 位，没有重复逻辑，因此最后 6 位可能提供了足够的区分度。

先倒序存储，然后再创建前缀索引。

如果存储身份证的时候倒过来存，每次查询的时候,可以这样：

select field list from t where id card reverse('input id card string);
第二种方式使用 hash 字段

可以使用表上再创建一个整数字段，来保持身份证的校验码，同时在这个字段创建索引。

alter table t add id card crc int unsigned, add index（id_card_crc);
每次插入新记录的时候，都同时使用 crc32 这个函数 得到校验码填到这个新字段，校验码可能存在冲突，也就是两个不同的身份证通过 crc32() 函数得到的结果可能是相同的，查询要查询语句  where 部分判断 id_card 的值是精确相同的。

### 排序

全字段排序 VS row_id排序

MySQL 的一个设计思想：如果内存够，就要多利用内存，尽量减少磁盘访问。 对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。

如果数据量很大，内存中无法存下这么多，就会使用磁盘临时文件来辅助排序，称为外部排序；
外部排序，MySQL会分为好几份单独的临时文件来存放排序后的数据，一般是磁盘文件中进行归并，然后将这些文件合并成一个大文件；

参考：
https://blog.csdn.net/qq_29066329/article/details/90036836